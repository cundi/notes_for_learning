# Go Internals

知识点：

- Go编译器
- Go的垃圾回收原理
- 如何检查垃圾回器的操作
- 在Go程序中调用C代码
- 在C程序中调用Go代码
- 函数panic()和recover()
- unsafe包
- 好用且具有技巧性的defer关键字
- Linux工具 strace(1)
- FreeBSD系统中的dtrace(1)工具
- 查找Go环境变量中的信息
- 节点树
- Go汇编器

## Go编译器

go tool compile命令将源码输出为一个以`.o`为扩展名的**对象文件**。

而对象文件是一个包含很多时候不可以被直接执行的二进制**对象代码**。

```go
$ go tool compile unsafe.go
$ ls -l unsafe.o
-rw-r--r-- 1 mtsouk staff
$ file unsafe.o
unsafe.o: data
```

`--pack`参数将输出一个扩展名为`.a`的**归档文件**。

**归档文件**：是一个包含一个或者多个文件的二进制文件，主要用途是把多个文件组合成一个文件。这种归档格式在Go中也被称为**ar**。

```go
$ go tool compile -pack unsafe.go
$ ls -l unsafe.a
-rw-r--r-- 1 mtsouk staff 5680 Oct 30 19:52 unsafe.a
$ file unsafe.a
unsafe.a: current ar archive
```

## 垃圾回收

### 三色算法

### Go垃圾回收器的细节

### 不安全代码

### 关于unsafe包

### unsafe包的又一个示例

## 在Go中调用C代码

### 在同一个文件中调用C代码

```go
/**
cGo.go
**/

package main
//#include <stdio.h>
//void callC() {
//
printf("Calling C code!\n");
//}
import "C"

import "fmt"
func main() {
    fmt.Println("A Go statement!")
    C.callC()
    fmt.Println("Another Go statement!")
}
```

执行结果

```shell
$ go run cGo.go
A Go statement!
Calling C code!
Another Go statement!
```

### 在不同的文件中调用C代码

### C代码

### Go代码

### 混合Go和C代码

## 在C程序中调用Go代码

### Go包

### C程序中所使用的代码

## defer关键字

`defer`关键字延缓了函数的执行，直到外部函数有返回时。

用途：广泛用于文件输入和输出操作

使用理由：因为它帮助用户记住了何时关闭和打开文件。

被应用了defer的函数会在外部函数返回后，按照**后进先出**(LIFO)的顺序执行。

```go
/*
defer.go
*/

package main

import (
    "fmt"
)

func d1() {
    for i := 3; i > 0; i-- {
        defer fmt.Print(i, " ")
    }
}

// d2()函数将被执行三次，且应用了defer关键字的匿名函数不接受参数
func d2() {
    for i := 3; i > 0; i-- {
        defer func() {
            fmt.Print(i, " ")
        }()
    }
    fmt.Println()
}

func d3() {
    for i := 3; i > 0; i-- {
        defer func(n int) {
            fmt.Print(n, " ")
        }(i)
    }
}

func main() {
    d1()
    d2()
    fmt.Println()
    d3()
    fmt.Println()
}
```

上面代码的执行结果如下：

```shell
$ go run defer.go
1 2 3
0 0 0
1 2 3
```

执行结果的解析：

输出中的第一行，是d1()函数在返回时，对被defer函数会将结果以LIFO方式返回，即，`1 2 3`。
第二行输出中，被defer的匿名函数是在for循环结束后ｉ的值为0。该匿名函数无参数，这就意味着，进行了三次求0的i值。这种让人陷入困惑的代码会带来恼人的bug，尽力避免在实际项目中使用。

