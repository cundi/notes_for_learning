# 变量和常量

## 变量

### typedef 关键字

typedef用于对已存在对数据类型创建别名

```c
typedef int interger;

integer count;

count = 1;
```

### 常见错误

- 变量未被初始化

- 使用float/double类型变量存储整数

- 初始化变量超出了允许范围

```c
int weight = 100000;
unsigned int value = -2500;
```

## 常量

### 字面常量 Literal Constants

字面常量：值直接写入源码，不论是否需要。

```c
int count = 20;
```

### 符号常量 Symbolic Constants

### #define指令

```c
#define PI 3.14159
#define PIPETTE 100
```

### const关键字

```c
const int count = 100;
const float pi = 3.14159;
const long debt = 1200000, float tax_rate = 0.21;
```

## 示例

```c
/* const.c */
#include <stdio.h>

#define PER_CENTER_METER 100

const int TARGET_YEAR = 2010;

long m, cm;
int year, age;

int main(void)
{
    printf("Enter your height in cm: "  );
    scanf("%d", &cm);
    printf("Enter your year of birth: ");
    scanf("%d", &year);

    m = cm * PER_CENTER_METER;
}
```

## static 变量

- 静态变量在程序运行时会被保留，而普通变量在被函数调用后就已经在内存中被销毁了
- 静态变量是以数据分段形式被分配内存的，而不是栈分段
- 类似全局变量，如果没有明确初始化静态变量，则默认初始化值为０
- 静态变量仅可使用字面常量初始化
- 静态变量和静态函数的目的在于限制该变量的变量域和

## extern　变量

能作为一个可以用在其他文件中的全局变量

```c
extern int flag;
```

## Volatile 变量

告诉编译器不要做出任何的优化

```c
typedef struct
{
  int command;
  int data;
  int isbusy;
} MyHardwareGadget;
```

```c
void SendCommand (MyHardwareGadget * gadget, int command, int data)
{
  // wait while the gadget is busy:
  while (gadget->isbusy)
  {
    // do nothing here.
  }
  // set data first:
  gadget->data    = data;
  // writing the command starts the action:
  gadget->command = command;
}
```

编译器会data和command的执行顺序，而且它还会自作聪明的只被读取isbusy一次就用到循环中。

```c
void SendCommand (volatile MyHardwareGadget * gadget, int command, int data)
    {
      // wait while the gadget is busy:
      while (gadget->isbusy)
      {
        // do nothing here.
      }
      // set data first:
      gadget->data    = data;
      // writing the command starts the action:
      gadget->command = command;
    }
```

使用了volatile，可以移除内存分配，不在寄存器中缓存，也不会让编译器改变赋值顺序。

## restrict 关键字

仅c99之后才使用该关键字

restrict keyword is mainly used in pointer declarations as a type qualifier for pointers.

It doesn’t add any new functionality. It is only a way for programmer to inform about an optimizations that compiler can make.

restrict没有

When we use restrict with a pointer ptr, it tells the compiler that ptr is the only way to access the object pointed by it and compiler doesn’t need to add any additional checks.
If a programmer uses restrict keyword and violate the above condition, result is undefined behavior.
restrict is not supported by C++. It is a C only keyword.

```ｃ
// C program to use restrict keyword.
#include <stdio.h>

// Note that the purpose of restrict is to 
// show only syntax. It doesn't change anything 
// in output (or logic). It is just a way for 
// programmer to tell compiler about an 
// optimization 
void use(int* a, int* b, int* restrict c) 
{ 
	*a += *c; 

	// Since c is restrict, compiler will 
	// not reload value at address c in 
	// its assembly code. Therefore generated 
	// assembly code is optimized 
	*b += *c; 
} 

int main(void) 
{ 
	int a = 50, b = 60, c = 70; 
	use(&a, &b, &c); 
	printf("%d %d %d", a, b, c); 
	return 0; 
} 
```
