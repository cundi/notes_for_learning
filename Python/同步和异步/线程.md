# 线程

- thread模块：用于小型任务，能力有限。
- threading模块：对线程提供了更强大、更高层次的支持。

## thread模块

thread.start_new_thread()方法接收以下参数：

- 需要运行的函数。
- 被运行函数的参数元组。
- 可选的命名参数字典。

示例：

```python
import thread
import time


# 打印时间5次，在每个“delay”之后
def print_time(threadName, delay):
    count = 0
    while count < 5:
        time.sleep(delay)
        count += 1
        print("%s: %s" % (threadName, time.ctime(time.time())))
        if delay == 2 and count == 2:
        thread.exit() # 正常终止线程


# 创建两个线程
try:
    thread.start_new_thread(print_time, ("Thread-1", 2))
    thread.start_new_thread(print_time, ("Thread-2", 4))
except as e:
    print(e)

# 保证程序一直运行
while True:
    pass
```

thread.allocate_lock方法返回锁供线程使用，而返回的锁对象有三个方法：

- acquire：为当前线程求求锁。可选的正整数作为参数。如果为0，
- release：为下一个线程释放锁。
- locked：如果锁已被某个线程请求则返回TRUE，反之FALSE。

```python
import thread
import time


global_value = 0

def run(threadName):
    global global_value
    print("%s with value %s" % (threadName, global_value))
    global_value += 1

# 多线程中锁对全局变量的处理
for i in range(10):
    thread.start_new_thread(run, ("Thread-" + str(i),))

while 1:
    pass
```

上面代码的输出结果为：

```shell
```

锁的请求和释放的例子：

```python
import thread
import time

global_value = 0
lock = thread.allocate_lock()

def run(threadName, lock):
    global global_value
    lock.acquire()
    local_copy = global_value
    print("%s with value %s" % (threadName, local_copy))
    global_value = local_copy + 1
    lock.release()

for i in range(10):
    thread.start_new_thread(run, ("Thread-" + str(=i), lock))

while 1:
    pass
```

## threading模块

应用场景比较：

- threading模块在 `I/O` 操作中能发挥最好，比如，下载远程资源、读取本地文件和目录。
- CPU多核计算应该使用multiprocessing模块

```python
import threading


def doubler(number):
    """
    """
    print(threading.currentThread().getName() + '\n')
    print(number * 2)
    print()


if __name__ == '__main__':
    for i in range(5):
        my_thread = threading.Thread(target=doubler, args=(i,))
        my_thread.start()
```

## GIL

全局解释器锁（Global Interpreter Lock）：由Python解释器控制的一次仅允许一个线程的锁。

变量引用计数示例：

```python
>>> import sys
>>> a = []
>>> b = a
>>> sys.getrefcount(a)
3
```

特征

- 一次仅允许一个线程处于执行状态。
- 对于计算密集型（CPU-bound）和多线程代码来说是性能瓶颈。

存在目的：

0x00) 内存中的使用引用计数变量追踪对象的引用次数，该变量的值为0时，对象占用的内存将会释放。

- 在竞争条件中，两个线程同时增加或者减少引用计数变量的值可以通过添加`锁`来保证安全。
- 对每个对象或者对象组添加锁会导致死锁（不止一个锁），以及重复获得和释放锁带来的性能下降。

### 计算密集型和读写密集型的比较

CPU-bound程序，对大限度的使用CPU，比如在矩阵乘法、搜索、图片处理等这类数学计算。

I/O-bound程序，花费时间在等待来自用户、文件、数据库、网络等的输入和输出。比如用户在输入提示时的思考、运行在数据库自身进程中的查询操作。

比较计算密集型计算中的单线程和多线程：

- GIL prevented the CPU-bound threads from executing in paralle；
- GIL does not have much impact on the performance of I/O-bound multi-threaded programs as the lock is shared between threads while they are waiting for I/O.

```python
# single_threaded.py
import time

COUNT = 50000000

def countdown(n):
    while n>0:
        n -= 1

start = time.time()
countdown(COUNT)
end = time.time()

print('Time taken in seconds -', end - start)
```

```python
# multi_threaded.py
import time
from threading import Thread

COUNT = 50000000

def countdown(n):
    while n>0:
        n -= 1

t1 = Thread(target=countdown, args=(COUNT//2,))
t2 = Thread(target=countdown, args=(COUNT//2,))

start = time.time()
t1.start()
t2.start()
t1.join()
t2.join()
end = time.time()

print('Time taken in seconds -', end - start)
```




## 总结

- GIL解决了Python的什么问题？

两个线程同时增加和减少引用计数变量的值，不释放所导致的内存泄露，不正确的释放（比如释放使用中对象引用的内存）导致的崩溃。

- 为什么选择GIL作为解决方案？
- 多线程在Python程序中的影响是什么？
- 为什么GIL还没被移除？attempts broke the existing C extensions which depend heavily on the solution that the GIL provides.  cannot bring a change as significant as the removal of GIL without causing backward incompatibility issues.
- 为什么在Python 3中没被移除？
- 如何使用Python GIL？
